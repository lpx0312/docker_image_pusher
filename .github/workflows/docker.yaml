name: Docker

on:
  workflow_dispatch:
  push:
    branches: [ main ]

env:
  ALIYUN_REGISTRY: "${{ secrets.ALIYUN_REGISTRY }}"
  ALIYUN_NAME_SPACE: "${{ secrets.ALIYUN_NAME_SPACE }}"
  ALIYUN_REGISTRY_USER: "${{ secrets.ALIYUN_REGISTRY_USER }}"
  ALIYUN_REGISTRY_PASSWORD: "${{ secrets.ALIYUN_REGISTRY_PASSWORD }}"

jobs:
  build:
    name: Pull
    runs-on: ubuntu-latest
    steps:
    - name: Checkout Code
      uses: actions/checkout@v4
    - name: Install latest Skopeo
      run: |
        # 以下是一个基于Ubuntu的示例，其他系统请参考Skopeo官方安装指南
        sudo apt-get update
        sudo apt-get install -y skopeo
        # 或者使用Snap安装可能版本更新
        # sudo snap install skopeo
    - name: Check Skopeo
      run: skopeo --version
    - name: Sync images using Skopeo
      run: |
        # 使用 skopeo 不需要 docker login，直接在命令中带入凭证，或者在这里登录
        # 为了方便，我们先登录，这样后续命令少写点参数（针对 docker hub 公共库不需要登录，针对阿里云需要）
        skopeo login -u "$ALIYUN_REGISTRY_USER" -p "$ALIYUN_REGISTRY_PASSWORD" "$ALIYUN_REGISTRY"
        
        # --- 下面是你原有的去重逻辑 (保持不变) ---
        declare -A duplicate_images
        declare -A temp_map
        
        # 第一遍循环：预处理，判断镜像是否重名
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then continue; fi
            
            image=$(echo "$line" | awk '{print $NF}')
            image="${image%%@*}"
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            name_space="${name_space}_"
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
            
            if [[ -n "${temp_map[$image_name]}" ]]; then
                 if [[ "${temp_map[$image_name]}" != $name_space  ]]; then
                    echo "Found duplicate image name: $image_name"
                    duplicate_images[$image_name]="true"
                 fi
            else
                temp_map[$image_name]=$name_space
            fi       
        done < images.txt
        
        # --- 第二遍循环：执行同步 (Skopeo 替换版) ---
        while IFS= read -r line || [ -n "$line" ]; do
            [[ -z "$line" ]] && continue
            if echo "$line" | grep -q '^\s*#'; then continue; fi
        
            echo "----------------------------------------------------------"
            echo "Processing: $line"
            
            # 解析平台参数 (保持你原有的解析逻辑)
            platform=$(echo "$line" | awk -F'--platform[ =]' '{if (NF>1) print $2}' | awk '{print $1}')
            
            # 处理后缀
            if [ -z "$platform" ]; then
                platform_suffix=""
            else
                platform_suffix="-${platform//\//-}"
            fi
            
            image=$(echo "$line" | awk '{print $NF}')
            image_name_tag=$(echo "$image" | awk -F'/' '{print $NF}')
            name_space=$(echo "$image" | awk -F'/' '{if (NF==3) print $2; else if (NF==2) print $1; else print ""}')
            image_name=$(echo "$image_name_tag" | awk -F':' '{print $1}')
        
            name_space_prefix=""
            if [[ -n "${duplicate_images[$image_name]}" ]]; then
               if [[ -n "${name_space}" ]]; then
                  name_space_prefix="${name_space}_"
               fi
            fi
            
            # 去除 digest
            image_name_tag="${image_name_tag%%@*}"
            
            # 构造源和目标地址
            # Skopeo 需要明确的 docker:// 前缀
            # 如果源地址没有域名 (如 nginx:latest)，Skopeo 默认处理很好，但加上 docker:// 是必须的
            SOURCE_IMAGE="docker://$image"
            TARGET_IMAGE="docker://$ALIYUN_REGISTRY/$ALIYUN_NAME_SPACE/$name_space_prefix$image_name_tag$platform_suffix"

            echo "Source: $SOURCE_IMAGE"
            echo "Target: $TARGET_IMAGE"

            # 构造 Skopeo 命令
            # --dest-creds 在上面 login 后其实可选，但加上保险
            # --src-tls-verify=false 有些私有库可能需要，DockerHub 一般不需要，这里默认设为默认值即可
            
            if [ -z "$platform" ]; then
                # 不指定平台时，默认只复制当前架构（而不是所有架构）
                echo "Running Skopeo Copy (Single Architecture)..."
                skopeo copy \
                    --image-parallel-copies 6 \
                    "$SOURCE_IMAGE" \
                    "$TARGET_IMAGE"
            else
                # 情况2：指定了架构 (如 linux/arm64)
                # 你的逻辑是把架构加到 Tag 后缀里，所以这里我们需要告诉 Skopeo 只拉取特定架构
                echo "Running Skopeo Copy (Specific Platform: $platform)..."
                
                # 解析 os 和 arch
                # 假设格式是 linux/arm64 或 linux/amd64
                override_os=$(echo $platform | cut -d'/' -f1)
                override_arch=$(echo $platform | cut -d'/' -f2)

                # 如果切分失败，给个默认值或报错，这里简单处理
                if [ -z "$override_arch" ]; then override_arch="amd64"; fi
                if [ -z "$override_os" ]; then override_os="linux"; fi

                skopeo copy \
                    --image-parallel-copies 6 \
                    --override-os "$override_os" \
                    --override-arch "$override_arch" \
                    "$SOURCE_IMAGE" \
                    "$TARGET_IMAGE"
            fi
            
            if [ $? -eq 0 ]; then
                echo "✅ Success"
            else
                echo "❌ Failed"
                exit 1
            fi

        done < images.txt
